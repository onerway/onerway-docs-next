---
title: 接受支付
description: 安全地在线接受支付。
---

::prose-tabs{variant="pill" sync="platform" :spread="false"}

  :::prose-tabs-item{label="网页端" icon="i-simple-icons-googlechrome"}

    ::prose-tabs{variant="link" sync="integration-type" :spread="false"}

      :::prose-tabs-item{label="Onerway 托管页面"}

        ::callout{color="neutral" icon="i-lucide:zap"}

        **最快集成方式** <br>

        Onerway 托管页面是最快的集成方式。无需前端代码,安全合规,支持所有支付方式。

        ::

      让 Onerway 托管一个优化的支付页面,处理所有支付细节。这是最快、最安全的集成方式,无需前端开发。

        ::payment-demo

        ::

      首先,[注册](/get-started/start-building/start-developing#create-a-sandbox-account) Onerway 账户。

      [获取 API 凭证](/get-started/start-building/start-developing#get-your-api-credentials)并从应用中访问 Onerway API:

        ::prose-accordion
        ---
        type: multiple
        defaultValue: ["0", "1", "2", "3"]
        ---

          :::prose-accordion-item{icon="healthicons:1"}

          #label
          ### 创建 Checkout Session

          #content
          Checkout Session 控制客户在支付流程中看到的内容。创建包含以下信息的 Checkout Session:

          - **单件商品明细**,包含价格和数量
          - **订单总额和币种**
          - **交易信息**,包含 `returnUrl`(支付后返回地址)和 `notifyUrl`(webhook 通知地址)

          创建 Checkout Session 后,将客户重定向到返回的 URL,让他们完成支付。

          ### 服务端实现 (Java)

            :::steps{level="4"}

            #### 添加 Maven 依赖

            首先,在 `pom.xml` 中添加必需的依赖:

              ::code-collapse{title="点击查看 Maven 依赖"}
              ```xml [pom.xml]
              <dependency>
                <groupId>com.sparkjava</groupId>
                <artifactId>spark-core</artifactId>
                <version>2.9.4</version>
              </dependency>

              <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.2</version>
              </dependency>
              ```
              ::

            #### 配置基础设置

            使用商户凭证设置配置:

              ::code-collapse{title="点击查看基础配置"}
              ```java [ServerDemo.java - 配置]
              import static spark.Spark.*;
              import spark.Request;
              import spark.Response;
              import com.fasterxml.jackson.databind.JsonNode;
              import com.fasterxml.jackson.databind.ObjectMapper;
              import com.fasterxml.jackson.core.type.TypeReference;
              import java.net.http.HttpClient;
              import java.net.http.HttpRequest;
              import java.net.http.HttpResponse;
              import java.net.URI;
              import java.nio.charset.StandardCharsets;
              import java.security.MessageDigest;
              import java.security.NoSuchAlgorithmException;
              import java.time.LocalDateTime;
              import java.time.format.DateTimeFormatter;
              import java.util.*;

              public class ServerDemo {
                private static final ObjectMapper JSON = new ObjectMapper();
                private static final String CHECKOUT_SESSION_URL = "https://sandbox-acq.onerway.com/txn/payment";
                private static final String MERCHANT_NO = "REPLACE_WITH_YOUR_MERCHANT_NO";
                private static final String DEFAULT_APP_ID = "REPLACE_WITH_YOUR_APP_ID";
                private static final String MERCHANT_SECRET = "REPLACE_WITH_YOUR_MERCHANT_SECRET";
                private static final String DEFAULT_RETURN_URL = "https://merchant.example.com/pay/return";
                private static final String DEFAULT_NOTIFY_URL = "https://merchant.example.com/pay/notify";

                private static final DateTimeFormatter DATETIME_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

                public static void main(String[] args) {
                  port(8080);
                  staticFiles.location("/public");
                  post("/create-checkout-session", ServerDemo::handleCheckoutSession);
                }
              }
              ```
              ::

              :::callout{color="neutral" icon="i-lucide:lightbulb"}
              使用 Onerway 控制台中的实际商户编号、应用 ID 和密钥替换凭证。
              :::

            #### 创建 Checkout Session 处理器

            实现端点来创建 Checkout Session 并返回支付页面 URL:

            ```java [ServerDemo.java - Checkout Session 处理器] {9,18-19,24-27}
            private static Object handleCheckoutSession(Request req, Response res) {
              res.type("application/json");

              // 构建支付请求体
              Map<String, String> body = buildCheckoutSessionBody(req);

              // 生成签名
              String signBase = buildSignBaseString(body, MERCHANT_SECRET);
              String sign = sha256Hex(signBase);
              body.put("sign", sign);

              try {
                String requestJson = toJson(body);

                // 发送请求到 Onerway Checkout Session API
                String responseJson = postJson(CHECKOUT_SESSION_URL, requestJson);

                // 从响应中提取重定向 URL
                String redirectUrl = extractRedirectUrl(responseJson);
                String transactionId = extractTransactionId(responseJson);

                // 返回重定向 URL 给前端
                Map<String, Object> result = new TreeMap<>();
                result.put("success", redirectUrl != null);
                result.put("redirectUrl", redirectUrl);
                result.put("transactionId", transactionId);
                return toJson(result);
              } catch (Exception e) {
                Map<String, Object> error = new TreeMap<>();
                error.put("success", false);
                error.put("error", "Failed to create checkout session: " + e.getMessage());
                return toJson(error);
              }
            }
            ```

              :::callout{color="primary" icon="i-lucide:info"}
              **重要字段**:
              - `redirectUrl`: 客户完成支付的 Onerway 托管页面
              - `transactionId`: 交易的唯一标识符,用于跟踪和查询
              - `sign`: SHA-256 签名,确保请求完整性
              :::

            #### 构建支付请求

            使用订单详情创建请求载荷:

              ::code-collapse{title="点击查看请求构建器"}
              ```java [ServerDemo.java - 请求构建器]
              private static Map<String, String> buildCheckoutSessionBody(Request req) {
                String merchantTxnId = String.valueOf(System.currentTimeMillis());
                String merchantTxnTime = LocalDateTime.now().format(DATETIME_FMT);

                String appId = resolveAppId(req);
                String returnUrl = resolveReturnUrl(appId);
                String billingInformation = buildBillingInformation("US", "test@example.com");
                String txnOrderMsg = buildTxnOrderMsg(appId, returnUrl, DEFAULT_NOTIFY_URL, req.ip());

                Map<String, String> body = new TreeMap<>();
                body.put("billingInformation", billingInformation);
                body.put("merchantCustId", "DEMO-CUSTOMER-ID");
                body.put("merchantNo", MERCHANT_NO);
                body.put("merchantTxnId", merchantTxnId);
                body.put("merchantTxnTime", merchantTxnTime);
                body.put("orderAmount", "1");
                body.put("orderCurrency", "USD");
                body.put("productType", "CARD");
                body.put("shippingInformation", billingInformation);
                body.put("subProductType", "DIRECT");
                body.put("txnOrderMsg", txnOrderMsg);
                body.put("txnType", "SALE");
                return body;
              }

              private static String buildBillingInformation(String country, String email) {
                Map<String, Object> billing = new TreeMap<>();
                billing.put("country", country);
                billing.put("email", email);
                return toJson(billing);
              }

              private static String buildTxnOrderMsg(String appId, String returnUrl, String notifyUrl, String transactionIp) {
                List<Map<String, String>> products = new ArrayList<>();
                Map<String, String> product = new TreeMap<>();
                product.put("price", "110.00");
                product.put("num", "1");
                product.put("name", "iphone11");
                product.put("currency", "USD");
                products.add(product);

                String productsJson = toJson(products);

                Map<String, Object> txnOrder = new TreeMap<>();
                txnOrder.put("products", productsJson);
                txnOrder.put("appId", appId);
                txnOrder.put("returnUrl", returnUrl);
                txnOrder.put("notifyUrl", notifyUrl);
                txnOrder.put("transactionIp", transactionIp);
                return toJson(txnOrder);
              }
              ```
              ::

            #### 处理签名和 API 通信

            实现签名生成和 API 通信:

              ::code-collapse{title="点击查看工具方法"}
              ```java [ServerDemo.java - 工具方法]
              // 按照 Onerway 规范生成签名
              private static String buildSignBaseString(Map<String, String> params, String secret) {
                boolean refundRequest = isRefundRequest(params);
                StringBuilder sb = new StringBuilder();
                for (Map.Entry<String, String> entry : new TreeMap<>(params).entrySet()) {
                  String key = entry.getKey();
                  String value = entry.getValue();
                  if (isNonEmpty(value) && !shouldFilterKey(key, refundRequest)) {
                    sb.append(value);
                  }
                }
                sb.append(secret);
                return sb.toString();
              }

              private static String sha256Hex(String input) {
                try {
                  MessageDigest md = MessageDigest.getInstance("SHA-256");
                  byte[] digest = md.digest(input.getBytes(StandardCharsets.UTF_8));
                  return HexFormat.of().formatHex(digest); // JDK 17+
                } catch (NoSuchAlgorithmException e) {
                  throw new RuntimeException("SHA-256 not available", e);
                }
              }

              // HTTP 通信
              private static String postJson(String url, String jsonBody) throws IOException, InterruptedException {
                HttpClient client = HttpClient.newHttpClient();
                HttpRequest request = HttpRequest.newBuilder()
                  .uri(URI.create(url))
                  .header("Content-Type", "application/json")
                  .POST(HttpRequest.BodyPublishers.ofString(jsonBody, StandardCharsets.UTF_8))
                  .build();
                HttpResponse<String> response = client.send(request,
                  HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
                return response.body();
              }

              // 响应解析 - 通用字段提取
              private static String extractJsonField(String responseJson, String path) {
                try {
                  JsonNode node = JSON.readTree(responseJson);

                  // 遍历路径 (例如 "data.redirectUrl" -> ["data", "redirectUrl"])
                  String[] pathParts = path.split("\\.");
                  for (String part : pathParts) {
                    node = node.path(part);
                    if (node.isMissingNode()) {
                      return null;
                    }
                  }

                  // 提取文本值
                  if (node.isTextual()) {
                    String value = node.asText().trim();
                    if (isNonEmpty(value)) {
                      return value;
                    }
                  } else if (node.isNumber()) {
                    // 同时支持数字字段
                    return node.asText();
                  }
                } catch (Exception e) {
                  System.err.println("Failed to extract field '" + path + "': " + e.getMessage());
                }
                return null;
              }

              // 从 API 响应中提取重定向 URL
              private static String extractRedirectUrl(String responseJson) {
                return extractJsonField(responseJson, "data.redirectUrl");
              }

              // 从 API 响应中提取交易 ID
              private static String extractTransactionId(String responseJson) {
                return extractJsonField(responseJson, "data.transactionId");
              }

              // JSON 工具
              private static String toJson(Object obj) {
                try {
                  return JSON.writeValueAsString(obj);
                } catch (Exception e) {
                  throw new RuntimeException(e);
                }
              }

              // 辅助方法
              private static boolean isRefundRequest(Map<String, String> params) {
                return params != null && params.containsKey("refundType");
              }

              private static boolean shouldFilterKey(String key, boolean refundRequest) {
                Set<String> EXCLUDED_KEYS_BASE = Set.of(
                  "originMerchantTxnId", "customsDeclarationAmount", "customsDeclarationCurrency",
                  "paymentMethod", "walletTypeName", "periodValue", "tokenExpireTime", "sign");
                return EXCLUDED_KEYS_BASE.contains(key) || (!refundRequest && "originTransactionId".equals(key));
              }

              private static String resolveAppId(Request req) {
                if (req == null) return DEFAULT_APP_ID;
                String[] candidates = {
                  req.queryParams("appId"), req.queryParams("app_id"),
                  req.headers("X-App-Id"), req.headers("appId")
                };
                for (String candidate : candidates) {
                  if (candidate != null && !candidate.trim().isEmpty()) {
                    return candidate.trim();
                  }
                }
                return DEFAULT_APP_ID;
              }

              private static String resolveReturnUrl(String appId) {
                return DEFAULT_RETURN_URL;
              }

              private static boolean isNonEmpty(String value) {
                return value != null && (value.length() > 0 || "0".equals(value));
              }
              ```
              ::

            :::

            ::callout{color="neutral" icon="i-lucide:lightbulb"}

            **预期响应:**
            ```json
            {
              "success": true,
              "transactionId": "1919259367895859200",
              "redirectUrl": "https://sandbox-checkout-sdk.onerway.com"
            }
            ```

            前端将使用 `redirectUrl` 将客户重定向到 Onerway 托管的支付页面。
            ::

          ### 前端集成

          在客户端,调用服务器端点并重定向到返回的 URL:

            :::code-group
            ```html [HTML]
            <!DOCTYPE html>
            <html>
              <head>
                <title>Checkout</title>
              </head>
              <body>
                <h1>Complete Your Payment</h1>
                <button id="checkout-button">Pay Now</button>

                <script>
                  document.getElementById('checkout-button').addEventListener('click', async () => {
                    // 调用服务器创建 Checkout Session
                    const response = await fetch('/create-checkout-session', {
                      method: 'POST'
                    })

                    const data = await response.json()

                    if (data.success && data.redirectUrl) {
                      // 重定向到 Onerway 托管页面
                      window.location.href = data.redirectUrl
                    } else {
                      alert('Failed to create checkout session')
                    }
                  })
                </script>
              </body>
            </html>
            ```

            ```vue [Vue]
            <template>
              <div>
                <h1>Complete Your Payment</h1>
                <button @click="handleCheckout">Pay Now</button>
              </div>
            </template>

            <script setup>
            const handleCheckout = async () => {
              try {
                const response = await fetch('/create-checkout-session', {
                  method: 'POST'
                })

                const data = await response.json()

                if (data.success && data.redirectUrl) {
                  // 重定向到 Onerway 托管页面
                  window.location.href = data.redirectUrl
                } else {
                  alert('Failed to create checkout session')
                }
              } catch (error) {
                console.error('Checkout error:', error)
                alert('An error occurred')
              }
            }
            </script>
            ```

            ```jsx [React]
            import { useState } from 'react'

            function CheckoutButton() {
              const [isLoading, setIsLoading] = useState(false)

              const handleCheckout = async () => {
                setIsLoading(true)

                try {
                  const response = await fetch('/create-checkout-session', {
                    method: 'POST'
                  })

                  const data = await response.json()

                  if (data.success && data.redirectUrl) {
                    // 重定向到 Onerway 托管页面
                    window.location.href = data.redirectUrl
                  } else {
                    alert('Failed to create checkout session')
                  }
                } catch (error) {
                  console.error('Checkout error:', error)
                  alert('An error occurred')
                } finally {
                  setIsLoading(false)
                }
              }

              return (
                <div>
                  <h1>Complete Your Payment</h1>
                  <button onClick={handleCheckout} disabled={isLoading}>
                    {isLoading ? 'Processing...' : 'Pay Now'}
                  </button>
                </div>
              )
            }

            export default CheckoutButton
            ```
            :::

          :::

          :::prose-accordion-item{icon="healthicons:2"}

          #label
          ### 处理支付后事件

          #content
          客户完成支付后,Onerway 会发送 [TXN](https://docs.onerway.com/apis/en/v0.6/transaction-notification#notification-parameters){badge="API"} 事件。参考 [webhook 指南](https://docs.onerway.com/apis/en/v0.6/transaction-notification){badge="API"}接收和处理这些事件,可能触发以下操作:

          - 向客户发送订单确认邮件
          - 在数据库中记录销售
          - 启动配送流程
          - 处理交易状态(`status` 字段)以处理异步通知。状态表示支付结果(例如 `S` 表示成功)

          应监听这些事件,而不是仅等待客户重定向回网站。仅从返回页面触发订单履行是不可靠的。设置集成监听异步事件,可以通过单一集成接受不同类型的支付方式。

          :::

          :::prose-accordion-item{icon="healthicons:3"}

          #label
          ### 测试集成

          #content
          测试 Checkout Session 集成:

          1. 创建 Checkout Session
          2. 重定向到 Onerway 托管页面
          3. 使用下表中的支付方式填写支付详情:

            - 卡号有效期输入任意未来日期
            - CVC 输入任意 3 位数字
            - 输入持卡人姓名

          4. 点击 **Pay**。Onerway 处理支付,然后将客户重定向回 `returnUrl`
          5. 前往控制台,在 :prose-link-switch{preset="merchant-dashboard" path="/transaction/query" label=" 交易页面"}查找支付。如果支付成功,将在列表中看到
          6. 点击支付查看详情,例如账单信息和购买商品列表。可以使用这些信息履行订单

          | 卡号                                           | 场景                                     | 如何测试                                              |
          | ---------------------------------------------- | ---------------------------------------- | ----------------------------------------------------- |
          | `4761344136141390`{:copy="true" format="card"} | 支付成功且无需身份验证                   | 使用此卡号填写信用卡表单,有效期、CVC 和持卡人姓名任意 |
          | `4021937195658141`{:copy="true" format="card"} | 卡被拒,拒绝代码如 `insufficient_funds`   | 使用此卡号填写信用卡表单,有效期、CVC 和持卡人姓名任意 |
          | `4000020951595032`{:copy="true" format="card"} | 支付需要[身份验证](/mock/authentication) | 使用此卡号填写信用卡表单,有效期、CVC 和持卡人姓名任意 |

          参见[测试](/mock/testing)了解测试集成的更多信息。
          :::

        ::

      :::

      :::prose-tabs-item{label="嵌入组件"}

        ::callout{color="neutral" icon="i-lucide:palette"}

        **平衡控制与便利** <br>

        嵌入 Onerway SDK 到页面中,既能自定义支付体验,又能保持 PCI 合规性。Onerway 处理敏感卡数据,你控制外观。

        ::

      将 Onerway SDK 嵌入到页面中,既能自定义外观,又保持 PCI 合规。Onerway 处理敏感卡数据,你控制用户体验。

        ::payment-demo

        ::

      首先,[注册](/get-started/start-building/start-developing#create-a-sandbox-account) Onerway 账户。

      [获取 API 凭证](/get-started/start-building/start-developing#get-your-api-credentials)并从应用中访问 Onerway API:

        ::prose-accordion
        ---
        type: multiple
        defaultValue: ["0", "1", "2", "3"]
        ---

          :::prose-accordion-item{icon="healthicons:1"}

          #label
          ### 创建 Payment Intent

          #content
          Payment Intent 表示从客户收取款项的意图。服务器创建包含支付详情的 Payment Intent,然后客户端使用 `transactionId` 和 `redirectUrl` 初始化 Onerway SDK。

          ### 服务端实现 (Java)

            :::steps{level="4"}

            #### 添加 Maven 依赖

            首先,在 `pom.xml` 中添加必需的依赖:

              ::code-collapse{name="Maven 依赖(与 Checkout Session 相同,需要时展开)"}
              ```xml [pom.xml]
              <dependency>
                <groupId>com.sparkjava</groupId>
                <artifactId>spark-core</artifactId>
                <version>2.9.4</version>
              </dependency>

              <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.2</version>
              </dependency>
              ```
              ::

            #### 配置基础设置

            设置商户配置:

              ::code-collapse{name="基础配置(展开查看)"}
              ```java [ServerDemo.java - 配置]
              import static spark.Spark.*;
              import spark.Request;
              import spark.Response;
              import com.fasterxml.jackson.databind.JsonNode;
              import com.fasterxml.jackson.databind.ObjectMapper;
              // ... 其他导入

              public class ServerDemo {
                private static final ObjectMapper JSON = new ObjectMapper();
                private static final String PAYMENT_INTENT_URL = "https://sandbox-acq.onerway.com/txn/payment";
                private static final String MERCHANT_NO = "REPLACE_WITH_YOUR_MERCHANT_NO";
                private static final String DEFAULT_APP_ID = "REPLACE_WITH_YOUR_APP_ID";
                private static final String MERCHANT_SECRET = "REPLACE_WITH_YOUR_MERCHANT_SECRET";
                private static final String DEFAULT_RETURN_URL = "https://merchant.example.com/pay/return";
                private static final String DEFAULT_NOTIFY_URL = "https://merchant.example.com/pay/notify";

                private static final DateTimeFormatter DATETIME_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

                public static void main(String[] args) {
                  port(8080);
                  post("/create-payment-intent", ServerDemo::handlePaymentIntent);
                }
              }
              ```
              ::

              :::callout{color="neutral" icon="i-lucide:lightbulb"}
              使用 Onerway 控制台中的实际商户编号、应用 ID 和密钥替换凭证。
              :::

            #### 创建 Payment Intent 处理器

            实现端点来创建 Payment Intent 并返回凭证给客户端:

            ```java [ServerDemo.java - Payment Intent 处理器] {9,18-19,24-27}
            private static Object handlePaymentIntent(Request req, Response res) {
              res.type("application/json");

              // 构建支付请求体
              Map<String, String> body = buildPaymentIntentBody(req);

              // 生成签名
              String signBase = buildSignBaseString(body, MERCHANT_SECRET);
              String sign = sha256Hex(signBase);
              body.put("sign", sign);

              try {
                String requestJson = toJson(body);

                // 发送请求到 Onerway Payment Intent API
                String responseJson = postJson(PAYMENT_INTENT_URL, requestJson);

                // 从响应中提取凭证
                String redirectUrl = extractRedirectUrl(responseJson);
                String transactionId = extractTransactionId(responseJson);

                // 返回凭证给前端
                Map<String, Object> result = new TreeMap<>();
                result.put("success", redirectUrl != null && transactionId != null);
                result.put("transactionId", transactionId);
                result.put("redirectUrl", redirectUrl);
                return toJson(result);
              } catch (Exception e) {
                Map<String, Object> error = new TreeMap<>();
                error.put("success", false);
                error.put("error", "Failed to create payment intent: " + e.getMessage());
                return toJson(error);
              }
            }
            ```

              :::callout{color="primary" icon="i-lucide:info"}
              **关键区别**:
              - Payment Intent 返回 `transactionId` 和 `redirectUrl` 供 SDK 使用
              - Checkout Session 直接重定向到托管页面
              - 两者使用相同的 API 端点但用途不同
              :::

            #### 构建 Payment Intent 请求

            使用订单详情创建请求载荷:

              ::code-collapse{name="请求构建器(与 Checkout Session 相同,需要时展开)"}
              ```java [ServerDemo.java - 请求构建器]
              private static Map<String, String> buildPaymentIntentBody(Request req) {
                String merchantTxnId = String.valueOf(System.currentTimeMillis());
                String merchantTxnTime = LocalDateTime.now().format(DATETIME_FMT);

                String appId = resolveAppId(req);
                String returnUrl = resolveReturnUrl(appId);
                String billingInformation = buildBillingInformation("US", "test@example.com");
                String txnOrderMsg = buildTxnOrderMsg(appId, returnUrl, DEFAULT_NOTIFY_URL, req.ip());

                Map<String, String> body = new TreeMap<>();
                body.put("billingInformation", billingInformation);
                body.put("merchantCustId", "DEMO-CUSTOMER-ID");
                body.put("merchantNo", MERCHANT_NO);
                body.put("merchantTxnId", merchantTxnId);
                body.put("merchantTxnTime", merchantTxnTime);
                body.put("orderAmount", "1");
                body.put("orderCurrency", "USD");
                body.put("productType", "CARD");
                body.put("shippingInformation", billingInformation);
                body.put("subProductType", "DIRECT");
                body.put("txnOrderMsg", txnOrderMsg);
                body.put("txnType", "SALE");
                return body;
              }

              private static String buildBillingInformation(String country, String email) {
                Map<String, Object> billing = new TreeMap<>();
                billing.put("country", country);
                billing.put("email", email);
                return toJson(billing);
              }

              private static String buildTxnOrderMsg(String appId, String returnUrl, String notifyUrl, String transactionIp) {
                List<Map<String, String>> products = new ArrayList<>();
                Map<String, String> product = new TreeMap<>();
                product.put("price", "110.00");
                product.put("num", "1");
                product.put("name", "iphone11");
                product.put("currency", "USD");
                products.add(product);

                String productsJson = toJson(products);

                Map<String, Object> txnOrder = new TreeMap<>();
                txnOrder.put("products", productsJson);
                txnOrder.put("appId", appId);
                txnOrder.put("returnUrl", returnUrl);
                txnOrder.put("notifyUrl", notifyUrl);
                txnOrder.put("transactionIp", transactionIp);
                return toJson(txnOrder);
              }
              ```
              ::

            #### 处理签名和 API 通信

            实现签名生成和 API 通信:

              ::code-collapse{name="工具方法(与 Checkout Session 相同,需要时展开)"}
              ```java [ServerDemo.java - 工具方法]
              // 按照 Onerway 规范生成签名
              private static String buildSignBaseString(Map<String, String> params, String secret) {
                boolean refundRequest = isRefundRequest(params);
                StringBuilder sb = new StringBuilder();
                for (Map.Entry<String, String> entry : new TreeMap<>(params).entrySet()) {
                  String key = entry.getKey();
                  String value = entry.getValue();
                  if (isNonEmpty(value) && !shouldFilterKey(key, refundRequest)) {
                    sb.append(value);
                  }
                }
                sb.append(secret);
                return sb.toString();
              }

              private static String sha256Hex(String input) {
                try {
                  MessageDigest md = MessageDigest.getInstance("SHA-256");
                  byte[] digest = md.digest(input.getBytes(StandardCharsets.UTF_8));
                  return HexFormat.of().formatHex(digest); // JDK 17+
                } catch (NoSuchAlgorithmException e) {
                  throw new RuntimeException("SHA-256 not available", e);
                }
              }

              // HTTP 通信
              private static String postJson(String url, String jsonBody) throws IOException, InterruptedException {
                HttpClient client = HttpClient.newHttpClient();
                HttpRequest request = HttpRequest.newBuilder()
                  .uri(URI.create(url))
                  .header("Content-Type", "application/json")
                  .POST(HttpRequest.BodyPublishers.ofString(jsonBody, StandardCharsets.UTF_8))
                  .build();
                HttpResponse<String> response = client.send(request,
                  HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
                return response.body();
              }

              // 响应解析 - 通用字段提取
              private static String extractJsonField(String responseJson, String path) {
                try {
                  JsonNode node = JSON.readTree(responseJson);

                  // 遍历路径 (例如 "data.redirectUrl" -> ["data", "redirectUrl"])
                  String[] pathParts = path.split("\\.");
                  for (String part : pathParts) {
                    node = node.path(part);
                    if (node.isMissingNode()) {
                      return null;
                    }
                  }

                  // 提取文本值
                  if (node.isTextual()) {
                    String value = node.asText().trim();
                    if (isNonEmpty(value)) {
                      return value;
                    }
                  } else if (node.isNumber()) {
                    // 同时支持数字字段
                    return node.asText();
                  }
                } catch (Exception e) {
                  System.err.println("Failed to extract field '" + path + "': " + e.getMessage());
                }
                return null;
              }

              // 从 API 响应中提取重定向 URL
              private static String extractRedirectUrl(String responseJson) {
                return extractJsonField(responseJson, "data.redirectUrl");
              }

              // 从 API 响应中提取交易 ID
              private static String extractTransactionId(String responseJson) {
                return extractJsonField(responseJson, "data.transactionId");
              }

              // JSON 工具
              private static String toJson(Object obj) {
                try {
                  return JSON.writeValueAsString(obj);
                } catch (Exception e) {
                  throw new RuntimeException(e);
                }
              }

              // 辅助方法
              private static boolean isRefundRequest(Map<String, String> params) {
                return params != null && params.containsKey("refundType");
              }

              private static boolean shouldFilterKey(String key, boolean refundRequest) {
                Set<String> EXCLUDED_KEYS_BASE = Set.of(
                  "originMerchantTxnId", "customsDeclarationAmount", "customsDeclarationCurrency",
                  "paymentMethod", "walletTypeName", "periodValue", "tokenExpireTime", "sign");
                return EXCLUDED_KEYS_BASE.contains(key) || (!refundRequest && "originTransactionId".equals(key));
              }

              private static String resolveAppId(Request req) {
                if (req == null) return DEFAULT_APP_ID;
                String[] candidates = {
                  req.queryParams("appId"), req.queryParams("app_id"),
                  req.headers("X-App-Id"), req.headers("appId")
                };
                for (String candidate : candidates) {
                  if (candidate != null && !candidate.trim().isEmpty()) {
                    return candidate.trim();
                  }
                }
                return DEFAULT_APP_ID;
              }

              private static String resolveReturnUrl(String appId) {
                return DEFAULT_RETURN_URL;
              }

              private static boolean isNonEmpty(String value) {
                return value != null && (value.length() > 0 || "0".equals(value));
              }
              ```
              ::

            :::

            ::callout{color="neutral" icon="i-lucide:lightbulb"}

            **预期响应:**
            ```json
            {
              "success": true,
              "transactionId": "1919259367895859200",
              "redirectUrl": "https://sandbox-checkout-sdk.onerway.com"
            }
            ```

            前端将使用这些值初始化 Onerway SDK 组件。
            ::

          ### 测试

          1. 启动服务器

          在浏览器中访问 `http://localhost:8080`{:copy="true"}。应该看到一个带有两个按钮的简单购买页面:

          ![Premium Gadget purchase page](/assets/images/checkout-demo.png)

          2. 创建 Payment Intent

          点击 **Payment Intent** 按钮。如果一切配置正确,将收到包含 `success: true`、`transactionId` 和 `redirectUrl` 的 JSON 响应。这些值将在下一步用于初始化 Onerway SDK。

            ::warning
            **凭证缺失** <br>

            如果看到以下响应,说明未配置 `MERCHANT_NO`、`DEFAULT_APP_ID` 或 `MERCHANT_SECRET`:

            ```json
            {
              "respCode": "40013",
              "respMsg": "Abnormal parameters (cannot be read)",
              "data": null
            }
            ```

            确保已按照[配置步骤](#configure-base-settings-1)中的说明设置了这些环境变量或配置值。
            ::

          :::

          :::prose-accordion-item{icon="healthicons:2"}

          #label
          ### 初始化 SDK

          #content
          创建 Payment Intent 后,使用返回的 `transactionId` 和 `redirectUrl` 在客户端初始化 Onerway SDK。SDK 渲染安全的支付表单,处理客户输入并处理支付。

          ### 加载 Onerway SDK

          在支付页面中包含 Onerway SDK 脚本。始终从官方 CDN 直接加载 SDK 以保持 PCI 合规并确保接收安全更新。

            :::callout{color="neutral" icon="i-lucide:shield-check"}
            **安全最佳实践** <br>

            永远不要打包或托管 SDK 副本。始终从 `https://checkout-sdk.onerway.com/v3/` 加载以保持 PCI DSS 合规并接收自动安全更新。
            :::

          #### 选项 1: 静态加载(推荐)

          将脚本添加到 HTML 文件头部或应用的根模板:

            :::code-group
            ```html [HTML]
            <head>
              <title>Checkout</title>
              <script src="https://checkout-sdk.onerway.com/v3/"></script>
            </head>
            ```

            ```vue [Vue (App.vue)]
            <!-- 在根 App.vue 或 index.html 中 -->
            <script setup>
            import { onMounted } from 'vue'

            onMounted(() => {
              // 加载后脚本将全局可用
              if (!document.querySelector('script[src*="checkout-sdk.onerway.com"]')) {
                const script = document.createElement('script')
                script.src = 'https://checkout-sdk.onerway.com/v3/'
                document.head.appendChild(script)
              }
            })
            </script>
            ```

            ```jsx [React (App.jsx)]
            // 在根 App.jsx 或 index.html 中
            import { useEffect } from 'react'

            function App() {
              useEffect(() => {
                // 全局加载 SDK 一次
                if (!document.querySelector('script[src*="checkout-sdk.onerway.com"]')) {
                  const script = document.createElement('script')
                  script.src = 'https://checkout-sdk.onerway.com/v3/'
                  document.head.appendChild(script)
                }
              }, [])

              return <YourApp />
            }
            ```
            :::

          #### 选项 2: 动态加载

          如果希望仅在需要时加载 SDK,可以在支付组件中动态加载(下面示例中展示)。

          ### 初始化 SDK

          创建容器元素并使用 Payment Intent 凭证初始化 SDK。

            :::callout{color="neutral" icon="i-lucide:lightbulb"}
            **SDK 加载选项** <br>

            如果在 HTML `<head>` 或根应用组件中加载了 SDK([选项 1](#option-1-static-loading-recommended)),`Pacypay` 构造函数已全局可用。可以直接初始化而无需再次加载脚本。

            如果动态加载 SDK(选项 2),需要先加载脚本,然后在加载完成后初始化。
            :::

            :::code-group
            ```html [HTML] {6,10,15-16,20-37}
            <html>
              <head>
                <title>Checkout</title>
              </head>
              <body>
                <div id="onerway-checkout"></div>

                <script>
                  // 加载 SDK 脚本
                  const script = document.createElement('script')
                  script.src = 'https://checkout-sdk.onerway.com/v3/'
                  document.body.appendChild(script)

                  script.onload = async function() {
                    // 从服务器获取 Payment Intent 凭证
                    const response = await fetch('/create-payment-intent')
                    const { transactionId, redirectUrl } = await response.json()

                    // 初始化 SDK
                    const pacypay = new Pacypay(transactionId, {
                      container: 'onerway-checkout',
                      locale: 'en',
                      environment: 'sandbox',
                      mode: 'CARD',
                      redirectUrl: redirectUrl,
                      config: {
                        subProductType: 'DIRECT'
                      },
                      onPaymentCompleted: function(result) {
                        console.log('Payment result:', result)
                        // 处理支付结果(见下一节)
                      },
                      onError: function(error) {
                        console.error('Payment error:', error)
                        // 处理错误
                      }
                    })
                  }
                </script>
              </body>
            </html>
            ```

            ```vue [Vue] {8-9,12-13,16-45}
            <template>
              <div>
                <div v-if="isLoading">Loading payment form...</div>
                <div v-else-if="error" class="error">{{ error }}</div>
                <div id="onerway-checkout"></div>
              </div>
            </template>

            <script setup>
            import { ref, onMounted } from 'vue'

            const isLoading = ref(true)
            const error = ref(null)
            const sdkInstance = ref(null)

            onMounted(async () => {
              try {
                // 加载 SDK 脚本
                const script = document.createElement('script')
                script.src = 'https://checkout-sdk.onerway.com/v3/'
                document.body.appendChild(script)

                script.onload = async () => {
                  // 从服务器获取 Payment Intent 凭证
                  const response = await fetch('/create-payment-intent')
                  const data = await response.json()

                  // 初始化 SDK
                  sdkInstance.value = new Pacypay(data.transactionId, {
                    container: 'onerway-checkout',
                    locale: 'en',
                    environment: 'sandbox',
                    mode: 'CARD',
                    redirectUrl: data.redirectUrl,
                    config: {
                      subProductType: 'DIRECT'
                    },
                    onPaymentCompleted: (result) => {
                      console.log('Payment result:', result)
                      // 处理支付结果(见下一节)
                    },
                    onError: (err) => {
                      error.value = err.message
                    }
                  })

                  isLoading.value = false
                }
              } catch (err) {
                error.value = 'Failed to load payment form'
                isLoading.value = false
              }
            })
            </script>
            ```

            ```jsx [React] {5-6,9-10,13-53}
            import { useState, useEffect } from 'react'

            function CheckoutForm() {
              const [isLoading, setIsLoading] = useState(true)
              const [error, setError] = useState(null)
              const [sdkInstance, setSdkInstance] = useState(null)

              useEffect(() => {
                let mounted = true

                const loadSDK = async () => {
                  try {
                    // 加载 SDK 脚本
                    const script = document.createElement('script')
                    script.src = 'https://checkout-sdk.onerway.com/v3/'
                    document.body.appendChild(script)

                    script.onload = async () => {
                      if (!mounted) return

                      // 从服务器获取 Payment Intent 凭证
                      const response = await fetch('/create-payment-intent')
                      const data = await response.json()

                      // 初始化 SDK
                      const instance = new Pacypay(data.transactionId, {
                        container: 'onerway-checkout',
                        locale: 'en',
                        environment: 'sandbox',
                        mode: 'CARD',
                        redirectUrl: data.redirectUrl,
                        config: {
                          subProductType: 'DIRECT'
                        },
                        onPaymentCompleted: (result) => {
                          console.log('Payment result:', result)
                          // 处理支付结果(见下一节)
                        },
                        onError: (err) => {
                          setError(err.message)
                        }
                      })

                      setSdkInstance(instance)
                      setIsLoading(false)
                    }
                  } catch (err) {
                    if (mounted) {
                      setError('Failed to load payment form')
                      setIsLoading(false)
                    }
                  }
                }

                loadSDK()

                return () => {
                  mounted = false
                }
              }, [])

              if (isLoading) return <div>Loading payment form...</div>
              if (error) return <div className="error">{error}</div>

              return <div id="onerway-checkout"></div>
            }

            export default CheckoutForm
            ```
            :::

          ### 处理支付结果

          客户完成支付表单时,SDK 调用 `onPaymentCompleted` 回调。适当处理不同的支付状态:

            :::code-group
            ```javascript [JavaScript] {4,7-10,12-16}
            onPaymentCompleted: function(result) {
              const { respCode, data } = result

              if (respCode === '20000') {
                // API 调用成功 - 检查支付状态
                switch (data.status) {
                  case 'S':
                    // 支付成功
                    alert('Payment completed successfully!')
                    window.location.href = '/order-confirmation'
                    break

                  case 'R':
                    // 需要 3D Secure 身份验证
                    // 重定向到身份验证页面
                    // 客户完成 3DS 后将返回到 returnUrl
                    window.location.href = data.redirectUrl
                    break
                }
              } else {
                // 支付失败
                alert('Payment failed: ' + result.respMsg)
              }
            }
            ```

            ```vue [Vue] {4,7-10,12-16}
            const handlePaymentCompleted = (result) => {
              const { respCode, data } = result

              if (respCode === '20000') {
                // API 调用成功 - 检查支付状态
                switch (data.status) {
                  case 'S':
                    // 支付成功
                    alert('Payment completed successfully!')
                    window.location.href = '/order-confirmation'
                    break

                  case 'R':
                    // 需要 3D Secure 身份验证
                    // 重定向到身份验证页面
                    // 客户完成 3DS 后将返回到 returnUrl
                    window.location.href = data.redirectUrl
                    break
                }
              } else {
                // 支付失败
                alert('Payment failed: ' + result.respMsg)
              }
            }
            ```

            ```jsx [React] {4,7-10,12-16}
            const handlePaymentCompleted = (result) => {
              const { respCode, data } = result

              if (respCode === '20000') {
                // API 调用成功 - 检查支付状态
                switch (data.status) {
                  case 'S':
                    // 支付成功
                    alert('Payment completed successfully!')
                    window.location.href = '/order-confirmation'
                    break

                  case 'R':
                    // 需要 3D Secure 身份验证
                    // 重定向到身份验证页面
                    // 客户完成 3DS 后将返回到 returnUrl
                    window.location.href = data.redirectUrl
                    break
                }
              } else {
                // 支付失败
                alert('Payment failed: ' + result.respMsg)
              }
            }
            ```
            :::

          **支付状态码:**

          | 状态 | 描述     | 何时发生                                             |
          | ---- | -------- | ---------------------------------------------------- |
          | `S`  | 成功     | 支付成功完成                                         |
          | `F`  | 失败     | 支付失败(仅在 `respCode !== '20000'` 的 `else` 分支) |
          | `R`  | 需要操作 | 客户需要完成 3D Secure 身份验证                      |

            :::callout{color="primary" icon="i-lucide:info"}
            **3D Secure 身份验证流程** <br>

            当 `status` 为 `R` 时,将客户重定向到 `data.redirectUrl` 进行 [3D Secure 身份验证](/mock/3d-secure)。完成身份验证后:

            1. **`onPaymentCompleted` 回调不会再次触发**
            2. 客户自动重定向到 `returnUrl`,并附加查询参数:

              - `transactionId`: 交易标识符
              - `status`: 支付状态(例如 `S` 表示成功,`F` 表示失败)
              - 其他订单相关信息

            **必须在 `returnUrl` 页面上处理返回:**

            ```javascript
            // 示例: 在返回页面从 URL 参数中提取支付结果
            const urlParams = new URLSearchParams(window.location.search)
            const transactionId = urlParams.get('transactionId')
            const status = urlParams.get('status')

            // 查询自己的后端以验证最终支付状态
            // 后端应检查数据库(通过 webhook 更新)或查询 Onerway 的 API
            async function verifyPayment() {
              const response = await fetch(`/api/payment/status?transactionId=${transactionId}`)
              const data = await response.json()

              if (data.status === 'S') {
                window.location.href = '/order-confirmation'
              } else if (data.status === 'F') {
                window.location.href = '/payment-failed'
              } else {
                // 支付仍在处理,延迟后重试
                setTimeout(verifyPayment, 2000)
              }
            }

            verifyPayment()
            ```

            **重要**: 前端查询**自己的后端**进行验证。后端可以通过以下方式获取支付结果:
            - **推荐**: 等待 Onerway 的 webhook 通知(在[下一步](#handle-post-payment-events-1)中介绍)
            - **备选**: 主动查询 Onerway 的 [Transaction Query API](https://docs.onerway.com/apis/en/v0.6/order-query){badge="API"},使用 `transactionId`
            :::

            :::callout{color="warning" icon="i-lucide:alert-triangle"}
            **需要服务端验证** <br>

            3DS 身份验证后,SDK 回调**不会**触发。始终在服务端验证支付状态:

            - **无 3DS**: SDK 回调提供即时前端反馈;仍需通过 webhook 在服务端验证
            - **有 3DS**: 无 SDK 回调;前端轮询后端 API,后端可以:
              - 检查数据库(通过 Onerway webhook 更新)
              - 主动查询 Onerway 的 [Transaction Query API](https://docs.onerway.com/apis/en/v0.6/order-query){badge="API"},使用 `transactionId`

            **永远不要仅信任 URL 参数** - 它们可以被篡改。始终通过后端验证支付状态以防止欺诈。
            :::

          ### 测试

          1. 加载已初始化 SDK 的支付页面
          2. 输入测试卡信息(使用[步骤 4](#test-your-integration-1) 中测试表的卡)
          3. 提交支付
          4. 对于需要 3DS 的卡(`4000020951595032`{:copy="true" format="card"}),将被重定向完成身份验证
          5. 成功支付或完成 3DS 后,验证支付出现在控制台中

            ::callout{color="neutral" icon="i-lucide:lightbulb"}
            SDK 自动处理表单验证、错误消息和支付方式选择。集成只需处理支付结果回调。
            ::

          :::

          :::prose-accordion-item{icon="healthicons:3"}

          #label
          ### 处理支付后事件

          #content
          客户完成支付后,Onerway 发送 [TXN](https://docs.onerway.com/apis/en/v0.6/transaction-notification#notification-parameters){badge="API"} 事件。参考 [webhook 指南](https://docs.onerway.com/apis/en/v0.6/transaction-notification){badge="API"}接收和处理这些事件,可能触发以下操作:

          - 向客户发送订单确认邮件
          - 在数据库中记录销售
          - 启动配送流程
          - 处理异步通知时处理交易状态(`status` 字段)。状态表示支付结果(例如 `S` 表示成功)

          应监听这些事件,而不是仅等待客户重定向回网站。仅从返回页面触发订单履行是不可靠的。设置集成监听异步事件,可以通过单一集成接受不同类型的支付方式。

          :::

          :::prose-accordion-item{icon="healthicons:4"}

          #label
          ### 测试集成

          #content
          测试 SDK 集成:

          1. 调用 `/create-payment-intent` 端点创建 Payment Intent
          2. 使用返回的 `transactionId` 和 `redirectUrl` 初始化 Onerway SDK
          3. 使用下表中的支付方式填写支付详情:

            - 卡号有效期输入任意未来日期
            - CVC 输入任意 3 位数字
            - 输入持卡人姓名

          4. 点击 **Pay**。SDK 将处理支付
          5. 前往控制台,在 :prose-link-switch{preset="merchant-dashboard" path="/transaction/query" label=" 交易页面"}查找支付。如果支付成功,将在列表中看到
          6. 点击支付查看详情,例如账单信息和购买商品列表。可以使用这些信息履行订单

          | 卡号                                           | 场景                                     | 如何测试                                              |
          | ---------------------------------------------- | ---------------------------------------- | ----------------------------------------------------- |
          | `4761344136141390`{:copy="true" format="card"} | 支付成功且无需身份验证                   | 使用此卡号填写信用卡表单,有效期、CVC 和持卡人姓名任意 |
          | `4021937195658141`{:copy="true" format="card"} | 卡被拒,拒绝代码如 `insufficient_funds`   | 使用此卡号填写信用卡表单,有效期、CVC 和持卡人姓名任意 |
          | `4000020951595032`{:copy="true" format="card"} | 支付需要[身份验证](/mock/authentication) | 使用此卡号填写信用卡表单,有效期、CVC 和持卡人姓名任意 |

          参见[测试](/mock/testing)了解测试集成的更多信息。
          :::

        ::

      :::

      :::prose-tabs-item{label="高级集成"}

        ::callout{color="neutral" icon="i-lucide:shield-alert"}

        **需要 [PCI DSS](https://www.pcisecuritystandards.org/about_us/){external: true} 合规** <br>

        此集成方式需要直接处理敏感卡数据,这意味着必须:
        - 维护有效的 PCI DSS 认证
        - 实施适当的加密和安全措施
        - 永不存储敏感身份验证数据(CVV 码)

        如果没有 PCI 认证,请使用 Onerway 托管页面或嵌入组件。

        ::

      使用 [Direct Payment](https://docs.onerway.com/apis/en/v0.6/api-card){badge="API"} 构建完全控制 UI 和支付流程的自定义支付表单。

        ::payment-demo

        ::

      首先,[注册](/get-started/start-building/start-developing#create-a-sandbox-account) Onerway 账户。

      [获取 API 凭证](/get-started/start-building/start-developing#get-your-api-credentials)并从应用中访问 Onerway API:

        ::prose-accordion
        ---
        type: multiple
        defaultValue: ["0", "1", "2", "3"]
        ---

          :::prose-accordion-item{icon="healthicons:1"}

          #label
          ### 创建 Payment Intent

          #content
          Payment Intent 表示从客户收取款项的意图。服务器创建包含支付详情和卡信息的 Payment Intent,然后将交易状态或 3DS 重定向 URL 返回给客户端。

          ### 服务端实现 (Java)

            :::steps{level="4"}

            #### 添加 Maven 依赖

            首先,在 `pom.xml` 中添加必需的依赖:

              ::code-collapse{name="Maven 依赖(与 Checkout Session 相同,需要时展开)"}
              ```xml [pom.xml]
              <dependency>
                <groupId>com.sparkjava</groupId>
                <artifactId>spark-core</artifactId>
                <version>2.9.4</version>
              </dependency>

              <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.2</version>
              </dependency>
              ```
              ::

            #### 配置基础设置

            使用 Direct Payment API 端点设置商户配置:

              ::code-collapse{name="基础配置(展开查看)"}
              ```java [ServerDemo.java - 配置]
              import static spark.Spark.*;
              import spark.Request;
              import spark.Response;
              import com.fasterxml.jackson.databind.JsonNode;
              import com.fasterxml.jackson.databind.ObjectMapper;
              // ... 其他导入

              public class ServerDemo {
                private static final ObjectMapper JSON = new ObjectMapper();
                private static final String DIRECT_PAYMENT_URL = "https://sandbox-acq.onerway.com/v1/txn/doTransaction";
                private static final String MERCHANT_NO = "REPLACE_WITH_YOUR_MERCHANT_NO";
                private static final String DEFAULT_APP_ID = "REPLACE_WITH_YOUR_APP_ID";
                private static final String MERCHANT_SECRET = "REPLACE_WITH_YOUR_MERCHANT_SECRET";
                private static final String DEFAULT_RETURN_URL = "https://merchant.example.com/pay/return";
                private static final String DEFAULT_NOTIFY_URL = "https://merchant.example.com/pay/notify";

                private static final DateTimeFormatter DATETIME_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

                public static void main(String[] args) {
                  port(8080);
                  post("/create-direct-payment", ServerDemo::handleDirectPayment);
                }
              }
              ```
              ::

              :::callout{color="neutral" icon="i-lucide:lightbulb"}
              使用 Onerway 控制台中的实际商户编号、应用 ID 和密钥替换凭证。
              :::

            #### 创建 Direct Payment 处理器

            实现处理卡数据并返回交易结果的支付端点:

            ```java [ServerDemo.java - Direct Payment 处理器] {9,20-21,27-31}
            private static Object handleDirectPayment(Request req, Response res) {
              res.type("application/json");

              // 从客户端请求解析卡信息
              String requestBody = req.body();
              Map<String, String> clientData = JSON.readValue(requestBody,
                new TypeReference<Map<String, String>>() {});

              // 使用卡信息构建支付请求
              Map<String, String> body = buildPaymentBodyWithCardInfo(clientData);

              // 生成签名
              String signBase = buildSignBaseString(body, MERCHANT_SECRET);
              String sign = sha256Hex(signBase);
              body.put("sign", sign);

              try {
                String requestJson = toJson(body);

                // 发送请求到 Onerway Direct Payment API
                String responseJson = postJson(DIRECT_PAYMENT_URL, requestJson);

                // 解析响应
                JsonNode responseNode = JSON.readTree(responseJson);
                String respCode = responseNode.path("respCode").asText();

                // 构建客户端响应
                Map<String, Object> result = new TreeMap<>();
                if ("20000".equals(respCode)) {
                  result.put("success", true);
                  result.put("data", responseNode.path("data"));
                } else {
                  result.put("success", false);
                  result.put("error", responseNode.path("respMsg").asText());
                }

                return toJson(result);
              } catch (Exception e) {
                Map<String, Object> error = new TreeMap<>();
                error.put("success", false);
                error.put("error", "Failed to process payment: " + e.getMessage());
                return toJson(error);
              }
            }
            ```

              :::callout{color="warning" icon="i-lucide:shield-alert"}
              **关键安全要求**

              - 永不记录或存储完整卡号或 CVV
              - 始终在服务端验证卡数据
              - 所有通信使用 HTTPS
              - 实施速率限制防止滥用
              :::

            #### 使用卡信息构建支付请求

            创建包含敏感卡数据的支付请求载荷:

              ::code-collapse
              ```java [ServerDemo.java - 包含卡信息的请求构建器]
              private static Map<String, String> buildPaymentBodyWithCardInfo(
                  Map<String, String> clientData) {
                String merchantTxnId = String.valueOf(System.currentTimeMillis());
                String merchantTxnTime = LocalDateTime.now().format(DATETIME_FMT);

                String appId = DEFAULT_APP_ID;
                String billingInformation = buildBillingInformation(
                  clientData.getOrDefault("country", "US"),
                  clientData.getOrDefault("email", "customer@example.com")
                );

                // 构建卡信息 JSON
                String cardInfo = buildCardInfo(
                  clientData.get("cardNumber"),
                  clientData.get("cvv"),
                  clientData.get("month"),
                  clientData.get("year"),
                  clientData.get("holderName")
                );

                String txnOrderMsg = buildTxnOrderMsg(
                  appId,
                  DEFAULT_RETURN_URL,
                  DEFAULT_NOTIFY_URL,
                  clientData.getOrDefault("ip", "127.0.0.1")
                );

                Map<String, String> body = new TreeMap<>();
                body.put("billingInformation", billingInformation);
                body.put("cardInfo", cardInfo);
                body.put("merchantCustId", "DEMO-CUSTOMER-ID");
                body.put("merchantNo", MERCHANT_NO);
                body.put("merchantTxnId", merchantTxnId);
                body.put("merchantTxnTime", merchantTxnTime);
                body.put("orderAmount", clientData.getOrDefault("amount", "100.00"));
                body.put("orderCurrency", clientData.getOrDefault("currency", "USD"));
                body.put("productType", "CARD");
                body.put("shippingInformation", billingInformation);
                body.put("subProductType", "DIRECT");
                body.put("txnOrderMsg", txnOrderMsg);
                body.put("txnType", "SALE");
                return body;
              }

              private static String buildCardInfo(String cardNumber, String cvv,
                  String month, String year, String holderName) {
                Map<String, String> cardInfo = new TreeMap<>();
                cardInfo.put("cardNumber", cardNumber);
                cardInfo.put("cvv", cvv);
                cardInfo.put("month", month);
                cardInfo.put("year", year);
                cardInfo.put("holderName", holderName);
                return toJson(cardInfo);
              }

              private static String buildBillingInformation(String country, String email) {
                Map<String, Object> billing = new TreeMap<>();
                billing.put("country", country);
                billing.put("email", email);
                billing.put("firstName", "John");
                billing.put("lastName", "Doe");
                return toJson(billing);
              }

              private static String buildTxnOrderMsg(String appId, String returnUrl,
                  String notifyUrl, String transactionIp) {
                List<Map<String, String>> products = new ArrayList<>();
                Map<String, String> product = new TreeMap<>();
                product.put("price", "100.00");
                product.put("num", "1");
                product.put("name", "Premium Product");
                product.put("currency", "USD");
                products.add(product);

                String productsJson = toJson(products);

                Map<String, Object> txnOrder = new TreeMap<>();
                txnOrder.put("products", productsJson);
                txnOrder.put("appId", appId);
                txnOrder.put("returnUrl", returnUrl);
                txnOrder.put("notifyUrl", notifyUrl);
                txnOrder.put("transactionIp", transactionIp);
                return toJson(txnOrder);
              }
              ```
              ::

            #### 处理签名和 API 通信

            实现签名生成和 API 通信:

              ::code-collapse{title="完整工具方法"}
              ```java [ServerDemo.java - 工具方法]
              // 按照 Onerway 规范生成签名
              private static String buildSignBaseString(Map<String, String> params, String secret) {
                boolean refundRequest = isRefundRequest(params);
                StringBuilder sb = new StringBuilder();
                for (Map.Entry<String, String> entry : new TreeMap<>(params).entrySet()) {
                  String key = entry.getKey();
                  String value = entry.getValue();
                  if (isNonEmpty(value) && !shouldFilterKey(key, refundRequest)) {
                    sb.append(value);
                  }
                }
                sb.append(secret);
                return sb.toString();
              }

              private static String sha256Hex(String input) {
                try {
                  MessageDigest md = MessageDigest.getInstance("SHA-256");
                  byte[] digest = md.digest(input.getBytes(StandardCharsets.UTF_8));
                  return HexFormat.of().formatHex(digest); // JDK 17+
                } catch (NoSuchAlgorithmException e) {
                  throw new RuntimeException("SHA-256 not available", e);
                }
              }

              // HTTP 通信
              private static String postJson(String url, String jsonBody)
                  throws IOException, InterruptedException {
                HttpClient client = HttpClient.newHttpClient();
                HttpRequest request = HttpRequest.newBuilder()
                  .uri(URI.create(url))
                  .header("Content-Type", "application/json")
                  .POST(HttpRequest.BodyPublishers.ofString(jsonBody, StandardCharsets.UTF_8))
                  .build();
                HttpResponse<String> response = client.send(request,
                  HttpResponse.BodyHandlers.ofString(StandardCharsets.UTF_8));
                return response.body();
              }

              // JSON 工具
              private static String toJson(Object obj) {
                try {
                  return JSON.writeValueAsString(obj);
                } catch (Exception e) {
                  throw new RuntimeException(e);
                }
              }

              // 辅助方法
              private static boolean isRefundRequest(Map<String, String> params) {
                return params != null && params.containsKey("refundType");
              }

              private static boolean shouldFilterKey(String key, boolean refundRequest) {
                Set<String> EXCLUDED_KEYS_BASE = Set.of(
                  "originMerchantTxnId", "customsDeclarationAmount",
                  "customsDeclarationCurrency", "paymentMethod", "walletTypeName",
                  "periodValue", "tokenExpireTime", "sign", "cardInfo");
                return EXCLUDED_KEYS_BASE.contains(key) ||
                  (!refundRequest && "originTransactionId".equals(key));
              }

              private static boolean isNonEmpty(String value) {
                return value != null && (value.length() > 0 || "0".equals(value));
              }
              ```
              ::

            :::

            ::callout{color="primary" icon="i-lucide:info"}
            **与 Checkout Session 的主要区别**

            - **API 端点**: 使用 `/v1/txn/doTransaction` 而非 `/txn/payment`
            - **卡数据**: 包含带有敏感卡详情的 `cardInfo` 参数
            - **PCI 范围**: 服务器处理原始卡数据(需要 PCI 合规)
            - **响应处理**: 可能返回 `status=R` 表示需要 3DS 身份验证
            ::

          ### 理解响应

          API 返回包含交易状态的响应:

          ```json
          {
            "respCode": "20000",
            "respMsg": "Success",
            "data": {
              "transactionId": "1919652333131005952",
              "status": "S",  // 或 "R" 表示需要 3DS
              "redirectUrl": null,  // status 为 "R" 时填充
              "actionType": null,  // 需要 3DS 时为 "RedirectURL"
              // ... 其他字段
            }
          }
          ```

          **响应状态值:**

          | 状态 | 描述              | 客户端操作             |
          | ---- | ----------------- | ---------------------- |
          | `S`  | 支付成功          | 显示确认页面           |
          | `R`  | 需要 3DS 身份验证 | 重定向到 `redirectUrl` |
          | `F`  | 支付失败          | 显示错误,允许重试      |

          :::


          :::prose-accordion-item{icon="healthicons:2"}

          #label
          ### 构建支付表单

          #content
          创建自定义支付表单来收集客户的卡信息。完全控制设计和用户体验,但需负责实施安全最佳实践。

            :::callout{color="warning" icon="i-lucide:shield-alert"}
            **安全要求**

            - 生产环境始终使用 HTTPS
            - 永不记录或存储完整卡号或 CVV 码
            - 在服务端验证卡数据,而非仅客户端
            - 实施 CSRF 保护
            - 使用内容安全策略(CSP)头
            :::

          ### HTML 支付表单

          创建收集必要卡信息的支付表单:

            :::code-group
            ```html [HTML] {6-7,9-10,12-13,15-16,18-19,21}
            <!DOCTYPE html>
            <html>
              <head>
                <title>Checkout</title>
                <style>
                  .form-group { margin-bottom: 15px; }
                  .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
                  .form-group input { width: 100%; padding: 8px; font-size: 16px; border: 1px solid #ddd; border-radius: 4px; }
                  .error { color: red; margin-top: 5px; font-size: 14px; }
                  button { background: #5469d4; color: white; padding: 12px 24px; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; width: 100%; }
                  button:disabled { background: #ccc; cursor: not-allowed; }
                  .card-row { display: flex; gap: 10px; }
                  .card-row .form-group { flex: 1; }
                </style>
              </head>
              <body>
                <h1>Complete Your Payment</h1>
                <form id="payment-form">
                  <div class="form-group">
                    <label for="card-number">Card Number</label>
                    <input
                      type="text"
                      id="card-number"
                      placeholder="4111 1111 1111 1111"
                      maxlength="19"
                      required
                    />
                    <div class="error" id="card-number-error"></div>
                  </div>

                  <div class="card-row">
                    <div class="form-group">
                      <label for="expiry-month">Expiry Month</label>
                      <input
                        type="text"
                        id="expiry-month"
                        placeholder="MM"
                        maxlength="2"
                        required
                      />
                    </div>
                    <div class="form-group">
                      <label for="expiry-year">Expiry Year</label>
                      <input
                        type="text"
                        id="expiry-year"
                        placeholder="YYYY"
                        maxlength="4"
                        required
                      />
                    </div>
                    <div class="form-group">
                      <label for="cvv">CVV</label>
                      <input
                        type="text"
                        id="cvv"
                        placeholder="123"
                        maxlength="4"
                        required
                      />
                    </div>
                  </div>

                  <div class="form-group">
                    <label for="cardholder-name">Cardholder Name</label>
                    <input
                      type="text"
                      id="cardholder-name"
                      placeholder="John Doe"
                      required
                    />
                  </div>

                  <div class="form-group">
                    <label for="email">Email</label>
                    <input
                      type="email"
                      id="email"
                      placeholder="customer@example.com"
                      required
                    />
                  </div>

                  <button type="submit" id="submit-button">Pay $100.00</button>
                  <div class="error" id="form-error"></div>
                </form>

                <script>
                  document.getElementById('payment-form').addEventListener('submit', async (e) => {
                    e.preventDefault();

                    const submitButton = document.getElementById('submit-button');
                    const formError = document.getElementById('form-error');

                    // 禁用按钮并显示加载状态
                    submitButton.disabled = true;
                    submitButton.textContent = 'Processing...';
                    formError.textContent = '';

                    // 格式化卡号(删除空格)
                    const cardNumber = document.getElementById('card-number').value.replace(/\s/g, '');

                    // 收集支付数据
                    const paymentData = {
                      cardNumber: cardNumber,
                      cvv: document.getElementById('cvv').value,
                      month: document.getElementById('expiry-month').value.padStart(2, '0'),
                      year: document.getElementById('expiry-year').value,
                      holderName: document.getElementById('cardholder-name').value,
                      email: document.getElementById('email').value,
                      amount: '100.00',
                      currency: 'USD',
                      ip: '' // 服务器将添加实际 IP
                    };

                    try {
                      // 发送支付数据到服务器
                      const response = await fetch('/create-direct-payment', {
                        method: 'POST',
                        headers: {
                          'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(paymentData)
                      });

                      const result = await response.json();

                      if (result.success && result.data) {
                        const status = result.data.status;
                        const actionType = result.data.actionType;

                        if (status === 'S') {
                          // 支付成功
                          window.location.href = '/order-confirmation?txn=' + result.data.transactionId;
                        } else if (status === 'R' && actionType === 'RedirectURL') {
                          // 需要 3DS 身份验证
                          window.location.href = result.data.redirectUrl;
                        } else {
                          // 支付失败
                          formError.textContent = result.data.respMsg || 'Payment failed. Please try again.';
                          submitButton.disabled = false;
                          submitButton.textContent = 'Pay $100.00';
                        }
                      } else {
                        formError.textContent = result.error || 'An error occurred. Please try again.';
                        submitButton.disabled = false;
                        submitButton.textContent = 'Pay $100.00';
                      }
                    } catch (error) {
                      console.error('Payment error:', error);
                      formError.textContent = 'Network error. Please check your connection and try again.';
                      submitButton.disabled = false;
                      submitButton.textContent = 'Pay $100.00';
                    }
                  });

                  // 用户输入时格式化卡号并添加空格
                  document.getElementById('card-number').addEventListener('input', (e) => {
                    let value = e.target.value.replace(/\s/g, '');
                    let formattedValue = value.match(/.{1,4}/g)?.join(' ') || value;
                    e.target.value = formattedValue;
                  });

                  // 卡号字段只允许数字
                  document.getElementById('card-number').addEventListener('keypress', (e) => {
                    if (!/[0-9\s]/.test(e.key)) {
                      e.preventDefault();
                    }
                  });

                  // CVV 和有效期字段只允许数字
                  ['cvv', 'expiry-month', 'expiry-year'].forEach(id => {
                    document.getElementById(id).addEventListener('keypress', (e) => {
                      if (!/[0-9]/.test(e.key)) {
                        e.preventDefault();
                      }
                    });
                  });
                </script>
              </body>
            </html>
            ```
            :::

            :::callout{color="neutral" icon="i-lucide:lightbulb"}
            **最佳实践**

            - **输入格式化**: 为卡号添加空格以提高可读性
            - **输入验证**: 在客户端和服务端都进行验证
            - **错误处理**: 提供清晰、可操作的错误消息
            - **加载状态**: 处理期间禁用提交按钮
            - **移动优化**: 使用 `font-size: 16px` 防止 iOS 缩放
            :::

          ### 框架示例(可选)

          如果使用 JavaScript 框架,以下是等效实现:

            ::code-collapse{name="Vue.js 示例(可选)"}
            ```vue [Vue]
            <template>
              <div>
                <h1>Complete Your Payment</h1>
                <form @submit.prevent="handleSubmit">
                  <div class="form-group">
                    <label for="card-number">Card Number</label>
                    <input
                      v-model="cardNumber"
                      type="text"
                      id="card-number"
                      placeholder="4111 1111 1111 1111"
                      maxlength="19"
                      @input="formatCardNumber"
                      required
                    />
                  </div>

                  <div class="card-row">
                    <div class="form-group">
                      <label>Expiry Month</label>
                      <input v-model="expiryMonth" placeholder="MM" maxlength="2" required />
                    </div>
                    <div class="form-group">
                      <label>Expiry Year</label>
                      <input v-model="expiryYear" placeholder="YYYY" maxlength="4" required />
                    </div>
                    <div class="form-group">
                      <label>CVV</label>
                      <input v-model="cvv" placeholder="123" maxlength="4" required />
                    </div>
                  </div>

                  <div class="form-group">
                    <label>Cardholder Name</label>
                    <input v-model="cardholderName" placeholder="John Doe" required />
                  </div>

                  <div class="form-group">
                    <label>Email</label>
                    <input v-model="email" type="email" placeholder="customer@example.com" required />
                  </div>

                  <button type="submit" :disabled="isLoading">
                    {{ isLoading ? 'Processing...' : 'Pay $100.00' }}
                  </button>
                  <div v-if="error" class="error">{{ error }}</div>
                </form>
              </div>
            </template>

            <script setup>
            import { ref } from 'vue'

            const cardNumber = ref('')
            const expiryMonth = ref('')
            const expiryYear = ref('')
            const cvv = ref('')
            const cardholderName = ref('')
            const email = ref('')
            const isLoading = ref(false)
            const error = ref('')

            const formatCardNumber = (e) => {
              let value = e.target.value.replace(/\s/g, '')
              cardNumber.value = value.match(/.{1,4}/g)?.join(' ') || value
            }

            const handleSubmit = async () => {
              isLoading.value = true
              error.value = ''

              try {
                const response = await fetch('/create-direct-payment', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    cardNumber: cardNumber.value.replace(/\s/g, ''),
                    cvv: cvv.value,
                    month: expiryMonth.value.padStart(2, '0'),
                    year: expiryYear.value,
                    holderName: cardholderName.value,
                    email: email.value,
                    amount: '100.00',
                    currency: 'USD'
                  })
                })

                const result = await response.json()

                if (result.success && result.data) {
                  if (result.data.status === 'S') {
                    window.location.href = '/order-confirmation?txn=' + result.data.transactionId
                  } else if (result.data.status === 'R' && result.data.actionType === 'RedirectURL') {
                    window.location.href = result.data.redirectUrl
                  } else {
                    error.value = result.data.respMsg || 'Payment failed. Please try again.'
                  }
                } else {
                  error.value = result.error || 'An error occurred. Please try again.'
                }
              } catch (err) {
                console.error('Payment error:', err)
                error.value = 'Network error. Please check your connection and try again.'
              } finally {
                isLoading.value = false
              }
            }
            </script>

            <style scoped>
            .form-group { margin-bottom: 15px; }
            .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
            .form-group input { width: 100%; padding: 8px; font-size: 16px; border: 1px solid #ddd; border-radius: 4px; }
            .error { color: red; margin-top: 10px; }
            button { background: #5469d4; color: white; padding: 12px 24px; border: none; border-radius: 4px; font-size: 16px; cursor: pointer; width: 100%; }
            button:disabled { background: #ccc; cursor: not-allowed; }
            .card-row { display: flex; gap: 10px; }
            </style>
            ```
            ::

            ::code-collapse{name="React 示例(可选)"}
            ```jsx [React]
            import { useState } from 'react'

            function PaymentForm() {
              const [cardNumber, setCardNumber] = useState('')
              const [expiryMonth, setExpiryMonth] = useState('')
              const [expiryYear, setExpiryYear] = useState('')
              const [cvv, setCvv] = useState('')
              const [cardholderName, setCardholderName] = useState('')
              const [email, setEmail] = useState('')
              const [isLoading, setIsLoading] = useState(false)
              const [error, setError] = useState('')

              const formatCardNumber = (value) => {
                const cleaned = value.replace(/\s/g, '')
                const formatted = cleaned.match(/.{1,4}/g)?.join(' ') || cleaned
                setCardNumber(formatted)
              }

              const handleSubmit = async (e) => {
                e.preventDefault()
                setIsLoading(true)
                setError('')

                try {
                  const response = await fetch('/create-direct-payment', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                      cardNumber: cardNumber.replace(/\s/g, ''),
                      cvv,
                      month: expiryMonth.padStart(2, '0'),
                      year: expiryYear,
                      holderName: cardholderName,
                      email,
                      amount: '100.00',
                      currency: 'USD'
                    })
                  })

                  const result = await response.json()

                  if (result.success && result.data) {
                    if (result.data.status === 'S') {
                      window.location.href = '/order-confirmation?txn=' + result.data.transactionId
                    } else if (result.data.status === 'R' && result.data.actionType === 'RedirectURL') {
                      window.location.href = result.data.redirectUrl
                    } else {
                      setError(result.data.respMsg || 'Payment failed. Please try again.')
                    }
                  } else {
                    setError(result.error || 'An error occurred. Please try again.')
                  }
                } catch (err) {
                  console.error('Payment error:', err)
                  setError('Network error. Please check your connection and try again.')
                } finally {
                  setIsLoading(false)
                }
              }

              return (
                <div>
                  <h1>Complete Your Payment</h1>
                  <form onSubmit={handleSubmit}>
                    <div className="form-group">
                      <label>Card Number</label>
                      <input
                        type="text"
                        value={cardNumber}
                        onChange={(e) => formatCardNumber(e.target.value)}
                        placeholder="4111 1111 1111 1111"
                        maxLength="19"
                        required
                      />
                    </div>

                    <div className="card-row">
                      <div className="form-group">
                        <label>Expiry Month</label>
                        <input
                          value={expiryMonth}
                          onChange={(e) => setExpiryMonth(e.target.value)}
                          placeholder="MM"
                          maxLength="2"
                          required
                        />
                      </div>
                      <div className="form-group">
                        <label>Expiry Year</label>
                        <input
                          value={expiryYear}
                          onChange={(e) => setExpiryYear(e.target.value)}
                          placeholder="YYYY"
                          maxLength="4"
                          required
                        />
                      </div>
                      <div className="form-group">
                        <label>CVV</label>
                        <input
                          value={cvv}
                          onChange={(e) => setCvv(e.target.value)}
                          placeholder="123"
                          maxLength="4"
                          required
                        />
                      </div>
                    </div>

                    <div className="form-group">
                      <label>Cardholder Name</label>
                      <input
                        value={cardholderName}
                        onChange={(e) => setCardholderName(e.target.value)}
                        placeholder="John Doe"
                        required
                      />
                    </div>

                    <div className="form-group">
                      <label>Email</label>
                      <input
                        type="email"
                        value={email}
                        onChange={(e) => setEmail(e.target.value)}
                        placeholder="customer@example.com"
                        required
                      />
                    </div>

                    <button type="submit" disabled={isLoading}>
                      {isLoading ? 'Processing...' : 'Pay $100.00'}
                    </button>
                    {error && <div className="error">{error}</div>}
                  </form>
                </div>
              )
            }

            export default PaymentForm
            ```
            ::

          :::

          :::prose-accordion-item{icon="healthicons:3"}

          #label
          ### 处理支付后事件

          #content
          客户提交支付表单后,根据交易状态处理响应。Onerway 可能需要额外的身份验证(3DS)或通过 webhook 通知支付结果。

          ### 处理 3DS 身份验证

          当支付响应包含 `status=R` 和 `actionType=RedirectURL` 时,必须重定向客户完成 3D Secure 身份验证:

            :::callout{color="primary" icon="i-lucide:info"}
            **3D Secure 身份验证流程**

            当 `status` 为 `R` 时,将客户重定向到 `redirectUrl` 进行 [3D Secure 身份验证](/mock/3d-secure)。完成身份验证后:

            1. **支付表单不会再次收到通知**
            2. 客户自动重定向到 `returnUrl`,并附加查询参数:

              - `transactionId`: 交易标识符
              - `status`: 支付状态(例如 `S` 表示成功,`F` 表示失败)
              - 其他订单相关信息

            **必须在 `returnUrl` 页面上处理返回:**

            ```javascript
            // 示例: 在返回页面从 URL 参数中提取支付结果
            const urlParams = new URLSearchParams(window.location.search)
            const transactionId = urlParams.get('transactionId')
            const status = urlParams.get('status')

            // 查询自己的后端以验证最终支付状态
            // 后端应检查数据库(通过 webhook 更新)或查询 Onerway 的 API
            async function verifyPayment() {
              const response = await fetch(`/api/payment/status?transactionId=${transactionId}`)
              const data = await response.json()

              if (data.status === 'S') {
                window.location.href = '/order-confirmation'
              } else if (data.status === 'F') {
                window.location.href = '/payment-failed'
              } else {
                // 支付仍在处理,延迟后重试
                setTimeout(verifyPayment, 2000)
              }
            }

            verifyPayment()
            ```

            **重要**: 前端查询**自己的后端**进行验证。后端可以通过以下方式获取支付结果:
            - **推荐**: 等待 Onerway 的 webhook 通知(下面介绍)
            - **备选**: 主动查询 Onerway 的 [Transaction Query API](https://docs.onerway.com/apis/en/v0.6/order-query){badge="API"},使用 `transactionId`
            :::

            :::callout{color="warning" icon="i-lucide:alert-triangle"}
            **需要服务端验证**

            始终在服务端验证支付状态:

            - **无 3DS**: 即时响应提供前端反馈;仍需通过 webhook 在服务端验证
            - **有 3DS**: 无即时反馈;前端轮询后端 API,后端可以:
              - 检查数据库(通过 Onerway webhook 更新)
              - 主动查询 Onerway 的 [Transaction Query API](https://docs.onerway.com/apis/en/v0.6/order-query){badge="API"},使用 `transactionId`

            **永远不要仅信任 URL 参数** - 它们可以被篡改。始终通过后端验证支付状态以防止欺诈。
            :::

          ### 支付状态码

          API 根据支付结果返回不同的状态码:

          | 状态 | 描述     | 何时发生                        | 下一步操作             |
          | ---- | -------- | ------------------------------- | ---------------------- |
          | `S`  | 成功     | 支付成功完成                    | 显示订单确认           |
          | `F`  | 失败     | 支付失败                        | 显示错误,允许重试      |
          | `R`  | 需要操作 | 客户需要完成 3D Secure 身份验证 | 重定向到 `redirectUrl` |

          ### 处理 Webhook 通知

          客户完成支付后,Onerway 发送 [TXN](https://docs.onerway.com/apis/en/v0.6/transaction-notification#notification-parameters){badge="API"} 事件。参考 [webhook 指南](https://docs.onerway.com/apis/en/v0.6/transaction-notification){badge="API"}接收和处理这些事件,可能触发以下操作:

          - 向客户发送订单确认邮件
          - 在数据库中记录销售
          - 启动配送流程
          - 处理异步通知时处理交易状态(`status` 字段)。状态表示支付结果(例如 `S` 表示成功)

          应监听这些事件,而不是仅等待客户重定向回网站。仅从返回页面触发订单履行是不可靠的。设置集成监听异步事件,可以通过单一集成接受不同类型的支付方式。

          **示例 webhook 载荷:**

          ```json
          {
            "notifyType": "TXN",
            "transactionId": "1919652333131005952",
            "txnType": "SALE",
            "merchantNo": "800209",
            "merchantTxnId": "2ce8fca1-f380-4c60-85ef-68a3a0c76ece",
            "responseTime": "2025-05-06 15:16:00",
            "txnTime": "2025-05-06 15:15:56",
            "txnTimeZone": "+08:00",
            "orderAmount": "100.00",
            "orderCurrency": "USD",
            "status": "S",
            "cardBinCountry": "US",
            "reason": "{\"respCode\":\"20000\",\"respMsg\":\"Success\"}",
            "sign": "ff999833f72c5a5875af7fa797020cfb83f9ca1f7408b2a4c85c039f835e6c62",
            "paymentMethod": "VISA",
            "channelRequestId": "8002091919652333131005952"
          }
          ```

          **webhook 端点必须:**

          1. 验证签名以确保请求来自 Onerway
          2. 检查 `status` 字段以确定支付结果
          3. 使用交易状态更新数据库
          4. 响应 `transactionId` 以确认收到
          5. 幂等处理重复通知

          示例 webhook 处理器:

            :::code-group
            ```java [Java]
            @Post("/webhook")
            public String handleWebhook(Request req, Response res) {
              String body = req.body();

              // 解析 webhook 数据
              Map<String, String> webhookData = JSON.readValue(body,
                new TypeReference<Map<String, String>>() {});

              // 验证签名
              String receivedSign = webhookData.remove("sign");
              String calculatedSign = generateSignature(webhookData, MERCHANT_SECRET);

              if (!calculatedSign.equals(receivedSign)) {
                return "Invalid signature";
              }

              // 处理 webhook
              String transactionId = webhookData.get("transactionId");
              String status = webhookData.get("status");
              String merchantTxnId = webhookData.get("merchantTxnId");

              // 更新数据库
              updateOrderStatus(merchantTxnId, status, webhookData);

              // 如果成功则发送确认邮件
              if ("S".equals(status)) {
                sendOrderConfirmation(merchantTxnId);
              }

              // 确认收到
              return transactionId;
            }
            ```

            ```javascript [Node.js]
            app.post('/webhook', (req, res) => {
              const webhookData = { ...req.body };

              // 验证签名
              const receivedSign = webhookData.sign;
              delete webhookData.sign;
              const calculatedSign = generateSignature(webhookData, MERCHANT_SECRET);

              if (calculatedSign !== receivedSign) {
                return res.status(400).send('Invalid signature');
              }

              // 处理 webhook
              const { transactionId, status, merchantTxnId } = webhookData;

              // 更新数据库
              updateOrderStatus(merchantTxnId, status, webhookData);

              // 如果成功则发送确认邮件
              if (status === 'S') {
                sendOrderConfirmation(merchantTxnId);
              }

              // 确认收到
              res.send(transactionId);
            });
            ```
            :::

            :::callout{color="neutral" icon="i-lucide:lightbulb"}
            **Webhook 最佳实践**

            - 处理前始终验证 webhook 签名
            - 幂等处理 webhook(处理重复通知)
            - 快速响应(5 秒内)以避免重试
            - 记录所有 webhook 数据以便调试和对账
            - 如果未收到响应,Onerway 将以 30 分钟间隔重试最多 3 次
            :::

          :::

          :::prose-accordion-item{icon="healthicons:4"}

          #label
          ### 测试集成

          #content
          测试 Direct Payment 集成:

          1. 启动服务器并导航到支付表单
          2. 使用下表中的测试卡详情填写表单
          3. 提交表单并验证响应
          4. 对于 3DS 卡,在重定向页面上完成身份验证
          5. 检查控制台 :prose-link-switch{preset="merchant-dashboard" path="/transaction/query" label="交易页面"}以验证支付
          6. 验证在 `notifyUrl` 收到 webhook 通知

          ### 测试卡

          使用以下测试卡号模拟不同的支付场景:

            ::prose-tabs{variant="link" sync="test-cards-advanced" :spread="false"}

              :::prose-tabs-item{label="Card"}
              | 卡号                                           | 场景                                     | 如何测试                                                                              |
              | ---------------------------------------------- | ---------------------------------------- | ------------------------------------------------------------------------------------- |
              | `4761344136141390`{:copy="true" format="card"} | 支付成功且无需身份验证                   | 使用任意未来有效期、任意 3 位 CVV 和任意持卡人姓名填写表单                            |
              | `4021937195658141`{:copy="true" format="card"} | 卡被拒,拒绝代码如 `insufficient_funds`   | 使用任意未来有效期、任意 3 位 CVV 和任意持卡人姓名填写表单                            |
              | `4000020951595032`{:copy="true" format="card"} | 支付需要[身份验证](/mock/authentication) | 使用任意未来有效期、任意 3 位 CVV 和任意持卡人姓名填写表单。在重定向页面完成 3DS 挑战 |
              :::

              :::prose-tabs-item{label="其他场景"}
              | 场景     | 描述           | 如何测试                                   |
              | -------- | -------------- | ------------------------------------------ |
              | 无效卡号 | 测试客户端验证 | 输入 `4111 1111 1111 1112`(无效 Luhn 校验) |
              | 过期卡   | 测试有效期验证 | 输入过去的有效期日期                       |
              | 无效 CVV | 测试 CVV 验证  | 仅输入 2 位数字或留空                      |
              | 网络错误 | 测试错误处理   | 停止服务器并提交表单                       |
              | 3DS 超时 | 测试 3DS 放弃  | 关闭 3DS 页面而不完成身份验证              |
              :::

            ::

          ### 验证清单

          测试后,验证集成:

          - [ ] **安全收集卡数据** - 通过 HTTPS
          - [ ] **验证输入** - 在客户端和服务端
          - [ ] **处理成功支付** - 重定向到确认页面
          - [ ] **处理失败支付** - 显示清晰的错误消息
          - [ ] **处理 3DS 身份验证** - 重定向到身份验证页面
          - [ ] **处理 webhook** - 正确更新订单状态
          - [ ] **验证 webhook 签名** - 处理前验证
          - [ ] **处理重复 webhook** - 幂等处理
          - [ ] **记录支付数据** - 用于调试和对账(不记录敏感卡数据)
          - [ ] **响应 webhook** - 5 秒内

            :::callout{color="success" icon="i-lucide:check-circle"}
            **测试清单完成?**

            验证所有场景正常工作后:

            1. 审查 PCI DSS 合规文档
            2. 确保所有安全措施到位
            3. 上线前使用真实小额交易测试
            4. 设置支付失败和 webhook 错误的监控
            5. 为团队记录支付流程
            :::

          参见[测试](/mock/testing)了解测试集成的更多信息。

          :::

        ::

      :::

    ::

  :::

  :::prose-tabs-item{label="iOS" icon="i-simple-icons-apple"}

    ::callout
    Lorem velit voluptate ex reprehenderit ullamco et culpa.
    ::

  :::

  :::prose-tabs-item{label="Android" icon="i-simple-icons-android"}

    ::callout
    Lorem velit voluptate ex reprehenderit ullamco et culpa.
    ::

  :::

::
